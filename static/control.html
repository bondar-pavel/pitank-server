<!--Original version is borrowed from https://github.com/dotdoom/rpi-tank-rack/-->
<html>
	<head>
		<title>Raspberry PI Tank Control</title>
		<link rel="stylesheet" type="text/css" href="/static/arrows.css">
		<style>
			.centered { text-align: center }
		</style>
	</head>
	<body style="font-family: monospace">
		<div><a href="/"><< Back</a></div><br>

		<div id='info' style='color: green'></div>
		<div id='warning' style='color: red'></div>
		<div style="float: left; padding: 10px">
			<img id='video'>
		</div>
		<div style="float: left">
			<table id='controls'>
				<tr>
					<td>
						<div id='tower_left' class="arrow tower_left inactive" onmousedown="button(this, true)" onmouseup="button(this, false)"></div>
					</td>
					<td><p class='centered'>tower</p></td>
					<td>
						<div id='tower_right' class="arrow tower_right inactive" onmousedown="button(this, true)" onmouseup="button(this, false)"></div>
					</td>
				</tr>
				<!-- Classic View -->
				<tr name='engine-classic'>
					<td/>
					<td>
						<div id='engine_forward' class="arrow engine_forward inactive" onmousedown="button(this, true)" onmouseup="button(this, false)"></div>
					</td>
				</tr>
				<tr name='engine-classic'>
					<td>
						<div id='engine_left' class="arrow engine_left inactive" onmousedown="button(this, true)" onmouseup="button(this, false)"></div>
					</td>
					<td/>
					<td>
						<div id='engine_right' class="arrow engine_right inactive" onmousedown="button(this, true)" onmouseup="button(this, false)"></div>
					</td>
				</tr>
				<tr name='engine-classic'>
					<td/>
					<td>
						<div id='engine_reverse' class="arrow engine_reverse inactive" onmousedown="button(this, true)" onmouseup="button(this, false)"></div>
					</td>
				</tr>
				<tr name='engine-classic'>
					<td colspan='3'>
						<p class='centered'>Classic View</p>
						<button onclick="view(true)">Switch to Tank View</button>
					</td>
				</tr>
				<!-- Tank View -->
				<tr name='engine-tank'>
					<td>
						<div id='trackleft_forward' class="arrow engine_forward inactive" onmousedown="button(this, true)" onmouseup="button(this, false)"></div>
					</td>
					<td/>
					<td>
						<div id='trackright_forward' class="arrow engine_forward inactive" onmousedown="button(this, true)" onmouseup="button(this, false)"></div>
					</td>
				</tr>
				<tr name='engine-tank'>
					<td>
						<div id='trackleft_reverse' class="arrow engine_reverse inactive" onmousedown="button(this, true)" onmouseup="button(this, false)"></div>
					</td>
					<td/>
					<td>
						<div id='trackright_reverse' class="arrow engine_reverse inactive" onmousedown="button(this, true)" onmouseup="button(this, false)"></div>
					</td>
				</tr>
				<tr name='engine-tank'>
					<td colspan='3'>
						<p class='centered'>Tank View</p>
						<button onclick="view(false)">Switch to Classic View</button>
					</td>
				</tr>
				<tr>
					<td colspan='3'>
						<button onclick="view('program')">Switch to Program View</button>
					</td>
				</tr>
			</table>
			<form id='program' method='POST' action='/' style='display: none'>
				Programming RPI-TANK<br/>
				<textarea name='program' rows='25' cols='80'>
reset
track_left.direction = :forward
sleep 5
track_left.direction = nil
track_right.direction = :reverse
tower.direction = :left # aka counter-clockwise
sleep 5
reset</textarea><br/>
				<input type='submit' value='Run' />
			</form>
		</div>

		<script type="text/javascript">
			document.onkeydown = function(e) { key(e.keyCode, true); }
			document.onkeyup = function(e) { key(e.keyCode, false); }

			document.getElementById('video').src = 'http://' + location.hostname + ':8280/?action=stream';

			// WebSocket connection to the server.
			var socket = null;
			// Currently pushed buttons.
			var actions = [];
			// Flag not to flood server with 'stop'.
			var stopped = true;
			// Flag to indicate program mode (no return).
			var program = false;
			// LocalDescription for WebRTC connection
			var localDescription = "";

			const urlParams = new URLSearchParams(window.location.search);
			const tankName = urlParams.get('name') || 'pitank';

			var action_to_track = {
				'engine_forward': ['trackright_forward', 'trackleft_forward'],
				'engine_right': ['trackleft_forward'],
				'engine_left': ['trackright_forward'],
				'engine_reverse': ['trackleft_reverse', 'trackright_reverse'],
			}

			// Init WebRTC
			let pc = new RTCPeerConnection({
				iceServers: [{urls: 'stun:stun.l.google.com:19302'}]
			})

			pc.onsignalingstatechange = e => warn(pc.signalingState)
			pc.oniceconnectionstatechange = e => warn(pc.iceConnectionState)
			pc.onicecandidate = event => {
				if (event.candidate === null) {
					localDescription = btoa(JSON.stringify(pc.localDescription))
				}
			}

			pc.ondatachannel = e => {
				let dc = e.channel
				warn('New DataChannel ' + dc.label)
				dc.onclose = () => console.log('dc has closed')
				dc.onopen = () => console.log('dc has opened')
				dc.onmessage = e => warn(`Message from DataChannel '${dc.label}' payload '${e.data}'`)

				dc.send("Connection established!");
			}

			// Converts list of actions to command for the server
			function get_commands(actions) {
				if (actions.length == 0) {
					return {commands: "stop"};
				}

				// use dict for commands to make sure each command appears only once
				let commands = {};
				for (var i = 0; i < actions.length; ++i) {
					let cmd = action_to_track[actions[i]];
					console.log("Processing", actions[i], cmd);
					if (cmd) {
						console.log("right", cmd);
						for (var j = 0; j < cmd.length; ++j) {
							commands[cmd[j]] = true;
						}
					} else {
						console.log("wrong", actions[i]);
						commands[actions[i]] = true;
					}
				}
				console.log("Commands:", commands);
				return {
					commands: Object.keys(commands).join(','),
					time: Date.now()
				};
			}
			// Send 'actions' to 'socket', with reconnect availability.
			function send_actions() {
				if (socket) {
					var stop_now = actions.length == 0;
					if (!(stop_now && stopped)) {
						socket.send(JSON.stringify(get_commands(actions)));
					}
					stopped = stop_now;
				} else {
					warn('connecting')
					socket = new WebSocket('ws://' + location.host + '/api/tanks/' + tankName + '/connect');

					socket.onopen = function(e) {
						warn(null);
						console.log('WebSocket: opened');
						send_actions();

						if (localDescription) {
							console.log("Sending localDescription: " + localDescription);
							socket.send(JSON.stringify({
								offer: localDescription
							}));
						} else {
							console.log("localDescription is not ready");
						}
					}
					socket.onclose = function(e) {
						socket = null;
						warn('WebSocket: closed (' + e.code + ')');
					}
					socket.onmessage = function(e) {
						try {
							var data = JSON.parse(e.data);
							if (data.time) {
								latency = Date.now() - data.time;
								console.log('Round trip time ' + latency + " ms");
								info('Round trip time ' + latency + " ms");
							}
							if (data.offer) {
								// Initialize webrtc connection with remote offer
								console.log("Received remote offer:" + offer);
								pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(atob(data.offer)))).catch(warn)
								pc.createAnswer().then(d => pc.setLocalDescription(d)).catch(warn)
							}
						} catch(err) {
							console.log('WebSocket: message ' + e.data);
							warn('WebSocket: message ' + e.data);
						}
					}
					socket.onerror = function(e) {
						warn('WebSocket: error');
					}
				}
			}

			function view(tank) {
				var tank_elements = document.getElementsByName('engine-tank');
				var classic_elements = document.getElementsByName('engine-classic');

				if (tank === 'program') {
					program = true;
					document.getElementById('controls').style.display = 'none';
					document.getElementById('program').style.display = '';
				} else {
					for (var i = 0; i < tank_elements.length; ++i) {
						tank_elements[i].style.display = tank ? '' : 'none';
					}
					for (var i = 0; i < classic_elements.length; ++i) {
						classic_elements[i].style.display = tank ? 'none' : '';
					}
				}
			}

			view(false);

			setInterval(function() {
					send_actions(actions);
				}, 500);

			function warn(text) {
				document.getElementById('warning').innerText = text;
			}
			function info(text) {
				document.getElementById('info').innerText = text;
			}

			function go(action, enabled) {
				var button = document.getElementById(action);
				button.className = button.className.replace(enabled ? ' inactive' : ' active',
				                                            enabled ? ' active' : ' inactive');

				if (enabled && action.indexOf('track') >= 0) {
					view(true);
				} else if (enabled && action.indexOf('engine') >= 0) {
					view(false);
				}

				for (var i = 0; i < actions.length; ++i) {
					if (actions[i] == action) {
						if (enabled) {
							var found = true;
						} else {
							actions.splice(i, 1);
							send_actions();
						}
						break;
					}
				}
				if (enabled && !found) {
					actions.push(action);
					send_actions();
				}

				return false;
			}

			var key_action_mapping = {
				37: 'engine_left',
				38: 'engine_forward',
				39: 'engine_right',
				40: 'engine_reverse',
				87: 'engine_forward',
				83: 'engine_reverse',
				65: 'engine_left',
				68: 'engine_right',
				81: 'trackleft_forward',
				69: 'trackright_forward',
				90: 'trackleft_reverse',
				67: 'trackright_reverse',
				219: 'tower_left',
				221: 'tower_right'
			};

			function key(code, enabled) {
				if (program) {
					return true;
				}
				var action = key_action_mapping[code];
				if (action) {
					go(action, enabled);
					return false;
				}
				return true;
			}

			function button(btn, enabled) {
				go(btn.id, enabled);
			}
		</script>
	</body>
</html>

